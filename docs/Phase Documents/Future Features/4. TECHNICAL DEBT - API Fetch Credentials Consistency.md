# API Fetch Credentials Consistency Refactor

**Category:** Technical Debt - Code Quality
**Priority:** Medium
**Effort:** 4-6 hours (isolated refactor, low risk)
**Impact:** Improves security posture and dev workflow reliability
**Status:** Identified - Ready for Implementation

---

## Executive Summary

NesVentory's frontend authentication uses HttpOnly JWT cookies (secure, prevents XSS), but approximately 88+ API functions (99 call-sites) in `src/lib/api.ts` use inline `...authHeaders()` instead of the secure `createFetchOptions()` helper. This works fine in same-origin production (Docker container), but silently fails in cross-origin scenarios (dev mode with separate Vite server, future multi-origin deployments).

This document identifies the inconsistency, explains the root cause, and provides a straightforward refactor plan.

---

## Problem Statement

### Current Authentication Pattern

NesVentory uses **HttpOnly cookies** for JWT authentication:

```typescript
// In login(), the server sets:
// Set-Cookie: access_token=<jwt>; HttpOnly; SameSite=Lax; Secure

// Cookie is automatically sent with:
// - Same-origin requests (always)
// - Cross-origin requests (only if credentials: 'include' is specified)
```

### Existing Patterns in api.ts

The codebase has **two conflicting patterns**:

#### Pattern 1: Secure (uses createFetchOptions) - **3 functions**
```typescript
export async function fetchItems(): Promise<Item[]> {
  const res = await fetch(`${API_BASE_URL}/api/items/`, createFetchOptions());
  return handleResponse<Item[]>(res);
}

// createFetchOptions automatically includes:
// credentials: 'include'
// headers: { "Accept": "application/json", ...authHeaders() }
```

#### Pattern 2: Insecure (uses authHeaders) - **~88 functions** (99 call-sites)
```typescript
export async function createLocation(location: LocationCreate): Promise<Location> {
  const res = await fetch(`${API_BASE_URL}/api/locations/`, {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
      "Accept": "application/json",
      ...authHeaders(),  // Returns {} - no credentials!
    },
    body: JSON.stringify(location),
  });
  return handleResponse<Location>(res);
}

// authHeaders() returns empty object:
function authHeaders(): Record<string, string> {
  return {};
}
```

### Why authHeaders() Exists

`authHeaders()` is a **legacy pattern** from when the app used Bearer tokens in Authorization header:

```typescript
// OLD (localStorage-based, vulnerable to XSS):
function authHeaders(): Record<string, string> {
  const token = localStorage.getItem('token');
  return token ? { 'Authorization': `Bearer ${token}` } : {};
}

// NEW (HttpOnly cookie, immune to XSS):
function authHeaders(): Record<string, string> {
  return {};  // Cookie sent automatically with credentials: 'include'
}
```

The function still exists but is now a **no-op returning empty object**.

### The Silent Failure Problem

When `credentials: 'include'` is missing:

| Scenario | Current (Pattern 2) | After Fix (Pattern 1) |
|----------|-------------------|-----------------|
| **Same-origin production** | Works ✅ (default) | Works ✅ |
| **Cross-origin Vite dev** | Silently fails ❌ | Requires proxy too ⚠️ |
| **Future multi-origin SaaS** | Fails ❌ | Works ✅ |
| **Security posture** | Good (HttpOnly) | Excellent (explicit) |

In cross-origin scenarios, the fetch call appears to succeed (no JS error), but the request is rejected as 401 Unauthorized because the cookie wasn't included.

**Note on cross-origin dev (Vite + Docker):** `SameSite=Lax` blocks subresource `fetch()` calls across different ports on `localhost` regardless of `credentials: 'include'`. Adding `credentials: 'include'` is necessary but not sufficient. A reverse proxy is also required — configure Vite's `server.proxy` to forward `/api` to `http://localhost:8181`, which makes both appear as the same origin to the browser. Alternatively, the cookie can be set to `SameSite=None; Secure`, but that requires HTTPS.

---

## Functions Requiring Update

Complete inventory of ~88 functions (99 call-sites) in `src/lib/api.ts` missing `credentials: 'include'`:

### Location Management (7 functions)
1. `createLocation()` - Line 362
2. `updateLocation()` - Line 375
3. `deleteLocation()` - Line 388
4. `uploadLocationPhoto()` - Line 408
5. `deleteLocationPhoto()` - Line 429
6. `uploadLocationVideo()` - Line 449
7. `deleteLocationVideo()` - Line 470

### Item Management (7 functions)
8. `createItem()` - Line 490
9. `fetchItem()` - Line 503 - has `...authHeaders()` only
10. `updateItem()` - Line 513
11. `deleteItem()` - Line 526
12. `enrichItem()` - Line 546
13. `uploadPhoto()` - Line 653
14. `deletePhoto()` - Line 678

### Photo Operations (2 functions)
15. `getPhoto()` - Line 698
16. `updatePhoto()` - Line 715

### Document Management (3 functions)
17. `uploadDocument()` - Line 731
18. `uploadDocumentFromUrl()` - Line 752
19. `deleteDocument()` - Line 773

### Bulk Operations (3 functions)
20. `bulkDeleteItems()` - Line 575
21. `bulkUpdateTags()` - Line 588
22. `bulkUpdateLocation()` - Line 605

### User Management (8 functions)
23. `adminCreateUser()` - Line 863
24. `getCurrentUser()` - Line 876
25. `setPassword()` - Line 886
26. `fetchUsers()` - Line 899
27. `updateUser()` - Line 909
28. `deleteUser()` - Line 922
29. `updateUserLocationAccess()` - Line 942
30. `getUserLocationAccess()` - Line 955

### Tag Management (3 functions)
31. `createTag()` - Line 971
32. `deleteTag()` - Line 984

### Encircle/Import (2 functions)
33. `previewEncircle()` - Line 1023
34. `importEncircle()` - Line 1038

### CSV Import (1 function)
35. `importCSV()` - Line 1081

### API Key Management (2 functions)
36. `generateApiKey()` - Line 1107
37. `revokeApiKey()` - Line 1118

### AI Detection (7 functions)
38. `getAIStatus()` - Line 1193
39. `detectItemsFromImage()` - Line 1203
40. `parseDataTagImage()` - Line 1217
41. `lookupBarcode()` - Line 1231
42. `scanBarcodeImage()` - Line 1256
43. `scanQRCodeImage()` - Line 1270
44. `testAIConnection()` - Line 1438

### Multi-Database UPC (5 functions)
45. `lookupBarcodeMulti()` - Line 1339
46. `getAvailableUPCDatabases()` - Line 1352
47. `getUPCDatabaseSettings()` - Line 1362
48. `updateUPCDatabaseSettings()` - Line 1372
49. `getAvailableAIProviders()` - Line 1385

### AI Provider Configuration (2 functions)
50. `getAIProviderSettings()` - Line 1395
51. `updateAIProviderSettings()` - Line 1405

### AI Scheduling (3 functions)
52. `getAIScheduleSettings()` - Line 1499
53. `updateAIScheduleSettings()` - Line 1509
54. `runAIValuation()` - Line 1522

### AI Enrichment (1 function)
55. `enrichFromDataTags()` - Line 1533

### Google Drive Backup (7 functions)
56. `getGDriveStatus()` - Line 1571
57. `connectGDrive()` - Line 1581
58. `disconnectGDrive()` - Line 1594
59. `createGDriveBackup()` - Line 1605
60. `listGDriveBackups()` - Line 1616
61. `deleteGDriveBackup()` - Line 1626

### Logging/Admin (8 functions)
62. `getLogSettings()` - Line 1672
63. `updateLogSettings()` - Line 1682
64. `deleteLogFiles()` - Line 1695
65. `rotateLogsNow()` - Line 1708
66. `getLogFiles()` - Line 1719
67. `getLogContent()` - Line 1747
68. `getIssueReportData()` - Line 1757

### Config Management (2 functions)
69. `getConfigStatus()` - Line 1802
70. `updateApiKeys()` - Line 1812

### Maintenance Tasks (5 functions)
71. `fetchMaintenanceTasks()` - Line 1827
72. `fetchMaintenanceTasksForItem()` - Line 1837
73. `createMaintenanceTask()` - Line 1847
74. `updateMaintenanceTask()` - Line 1860
75. `deleteMaintenanceTask()` - Line 1873

### Plugin Management (6 functions)
76. `fetchPlugins()` - Line 1942
77. `getPlugin()` - Line 1952
78. `createPlugin()` - Line 1962
79. `updatePlugin()` - Line 1975
80. `deletePlugin()` - Line 1988
81. `testPluginConnection()` - Line 2061

### System Settings (3 functions)
82. `getSystemSettings()` - Line 2028
83. `updateSystemSettings()` - Line 2038
84. `getLocationCategories()` - Line 2051

### Media Management (3 functions)
85. `getMediaStats()` - Line 2107
86. `listMedia()` - Line 2117
87. `bulkDeleteMedia()` - Line 2190
88. `updateMedia()` - Line 2212

### Printer Management (10 functions)
89. `getPrinterConfig()` - Line 2277
90. `updatePrinterConfig()` - Line 2287
91. `printLabel()` - Line 2300
92. `printTestLabel()` - Line 2313
93. `testPrinterConnection()` - Line 2324
94. `getPrinterModels()` - Line 2337
95. `checkSystemPrintersAvailable()` - Line 2367
96. `getSystemPrinters()` - Line 2377
97. `printToSystemPrinter()` - Line 2387
98. `printItemToSystemPrinter()` - Line 2406

### Phase 2D: Printer Profiles (9 functions)
99. `getPrinterProfiles()` - Line 2494 - **ALREADY HAS credentials: 'include'** ✅
100. `createPrinterProfile()` - Line 2505 - **ALREADY HAS credentials: 'include'** ✅
101. `deletePrinterProfile()` - Line 2519 - **ALREADY HAS credentials: 'include'** ✅
102. `getLabelProfiles()` - Line 2532 - **ALREADY HAS credentials: 'include'** ✅
103. `createLabelProfile()` - Line 2543 - **ALREADY HAS credentials: 'include'** ✅
104. `updateLabelProfile()` - Line 2557 - **ALREADY HAS credentials: 'include'** ✅
105. `deleteLabelProfile()` - Line 2571 - **ALREADY HAS credentials: 'include'** ✅
106. `getActivePrinterConfig()` - Line 2584 - **ALREADY HAS credentials: 'include'** ✅
107. `activatePrinterConfig()` - Line 2595 - **ALREADY HAS credentials: 'include'** ✅

**Note:** These 9 functions use a third hybrid pattern — they have explicit `credentials: 'include'` alongside `...authHeaders()` and manual headers, rather than using `createFetchOptions()`. They are functionally correct but stylistically inconsistent. Under a full Option A refactor, they should also be converted to `createFetchOptions()` for consistency, even though they are not broken.

### Public Endpoints — Do NOT Add credentials

The following fetch calls in `src/lib/api.ts` are intentionally unauthenticated and must be left without `credentials: 'include'` during the refactor:

| Function | Line | Reason |
|----------|------|--------|
| `fetchStatus()` | ~645 | Public health check |
| `registerUser()` | ~852 | Public signup endpoint |
| `getRegistrationStatus()` | ~1467 | Public — no auth required |
| `getGoogleOAuthStatus()` | ~1476 | Public — OAuth availability check |
| `getOIDCStatus()` | ~2160 | Public — OIDC availability check |
| `getOIDCLoginUrl()` | ~2169 | Public — OIDC login redirect |

Note: `login()`, `googleAuth()`, and `oidcCallback()` already correctly use `credentials: 'include'` (they are the cookie-setting entry points) and should be left as-is.

---

## Scope & Implementation Strategy

### Three Refactor Options

#### Option A: Use createFetchOptions (RECOMMENDED)
Convert all inline `fetch()` calls to use `createFetchOptions()` helper.

**Pros:**
- Centralized, consistent pattern
- Easy to audit (grep for `createFetchOptions`)
- Future-proof (changes in one place)

**Cons:**
- Requires helper to support all request types (method, body, headers)

**Code Example:**
```typescript
// Before
export async function createLocation(location: LocationCreate): Promise<Location> {
  const res = await fetch(`${API_BASE_URL}/api/locations/`, {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
      "Accept": "application/json",
      ...authHeaders(),
    },
    body: JSON.stringify(location),
  });
  return handleResponse<Location>(res);
}

// After (Option A)
export async function createLocation(location: LocationCreate): Promise<Location> {
  const res = await fetch(
    `${API_BASE_URL}/api/locations/`,
    createFetchOptions({
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(location),
    })
  );
  return handleResponse<Location>(res);
}
```

#### Option B: Add credentials: 'include' to all fetch calls
Add `credentials: 'include'` directly to each fetch call inline.

**Pros:**
- Minimal changes, explicit at each call site
- No refactoring of helper function

**Cons:**
- Repetitive, easy to miss a call
- Hard to audit (scatter pattern)
- Each change requires touching multiple lines

#### Option C: Hybrid (Pragmatic)
- New code always uses `createFetchOptions()`
- Update old code incrementally during feature work
- Add linter rule to catch missing `credentials: 'include'`

---

## Recommended Implementation Plan

### Phase 1: Enhance createFetchOptions

✅ **Already implemented** — `createFetchOptions()` at lines 322–332 of `src/lib/api.ts` already matches this implementation exactly. No changes needed. Proceed directly to Phase 2.

**Current implementation (no changes needed):**
```typescript
/**
 * Helper function for authenticated fetch calls
 * Automatically includes HttpOnly cookies in requests
 *
 * @param options RequestInit options (method, body, headers, etc.)
 * @returns RequestInit with credentials and auth headers set
 */
function createFetchOptions(options?: RequestInit): RequestInit {
  return {
    ...options,
    credentials: 'include', // Always include HttpOnly cookies
    headers: {
      "Accept": "application/json",
      ...authHeaders(),
      ...options?.headers,
    },
  };
}
```

### Phase 2: Batch Refactor (4-5 hours)

Systematic grep and replace approach:

**Step 1: Identify patterns** (15 min)
```bash
# Find all fetch calls with inline headers
grep -n "fetch(\`\${API_BASE_URL}" /data/NesVentory/src/lib/api.ts | wc -l

# Find functions using createFetchOptions (as control)
grep -c "createFetchOptions" /data/NesVentory/src/lib/api.ts
# Expected: ~15 currently using it
```

**Step 2: Convert by function type** (2-3 hours)

Organize refactoring by pattern:

1. **Simple GET requests** (easiest)
   ```typescript
   // Before
   const res = await fetch(`${API_BASE_URL}/api/items/`, {
     headers: { "Accept": "application/json", ...authHeaders() },
   });

   // After
   const res = await fetch(`${API_BASE_URL}/api/items/`, createFetchOptions());
   ```

2. **POST with JSON body**
   ```typescript
   // Before
   const res = await fetch(`${API_BASE_URL}/api/items/`, {
     method: "POST",
     headers: {
       "Content-Type": "application/json",
       "Accept": "application/json",
       ...authHeaders(),
     },
     body: JSON.stringify(item),
   });

   // After
   const res = await fetch(
     `${API_BASE_URL}/api/items/`,
     createFetchOptions({
       method: "POST",
       headers: { "Content-Type": "application/json" },
       body: JSON.stringify(item),
     })
   );
   ```

3. **FormData (multipart/form-data)**
   ```typescript
   // Before (don't set Content-Type - browser does)
   const res = await fetch(`${API_BASE_URL}/api/items/1/photos`, {
     method: "POST",
     headers: { ...authHeaders() },
     body: formData,
   });

   // After (same pattern - createFetchOptions handles it)
   const res = await fetch(
     `${API_BASE_URL}/api/items/1/photos`,
     createFetchOptions({ method: "POST", body: formData })
   );
   ```

4. **DELETE requests**
   ```typescript
   // Before
   const res = await fetch(`${API_BASE_URL}/api/items/1`, {
     method: "DELETE",
     headers: { ...authHeaders() },
   });

   // After
   const res = await fetch(
     `${API_BASE_URL}/api/items/1`,
     createFetchOptions({ method: "DELETE" })
   );
   ```

5. **PATCH requests**
   ```typescript
   // Same pattern as POST
   const res = await fetch(
     `${API_BASE_URL}/api/items/1/photos/2`,
     createFetchOptions({
       method: "PATCH",
       headers: { "Content-Type": "application/json" },
       body: JSON.stringify(updates),
     })
   );
   ```

**Step 3: Testing** (1-1.5 hours)

- Local dev test (all functions still work)
- Same-origin test (Docker container)
- Cross-origin test (Vite dev server against Docker backend)
- No logic changes, only how credentials are passed

### Phase 3: Validation (30 minutes)

**Pre-commit checks:**
```bash
# Verify all fetch calls use createFetchOptions or have explicit credentials: 'include'
grep -n "fetch(\`\${API_BASE_URL}" /data/NesVentory/src/lib/api.ts | \
  grep -v "createFetchOptions" | \
  grep -v "credentials:" | \
  wc -l
# Should return 0

# Check no remaining ...authHeaders() in fetch calls
grep -A 3 "fetch(" /data/NesVentory/src/lib/api.ts | grep "...authHeaders()"
# Should return 0
```

**Integration test:**
```bash
npm run build    # Ensure no TypeScript errors
npm run dev      # Test in dev mode with separate API server
```

---

## Impact Assessment

### Risk Level: **LOW**

- Pure refactor, no logic changes
- No new dependencies
- Backward compatible (credentials: 'include' already supported by all browsers)
- Same-origin production unaffected

### Effort Breakdown

| Task | Time | Difficulty |
|------|------|-----------|
| Analysis & planning | 30 min | Easy |
| Enhance createFetchOptions | 0 min | Already implemented |
| Batch refactor | 4-5 hours | Medium (repetitive) |
| Testing & validation | 1.5 hours | Medium |
| **Total** | **6-8 hours** | **Medium** |

### Priority Justification

**Why Medium, not Low:**

1. **Current production works** - Same-origin Docker deployment has no issues
2. **Not blocking feature work** - Can be done incrementally
3. **Good-to-have, not must-have** - Security posture is already solid (HttpOnly)

**Why not deprioritize further:**

1. **Improves dev workflow** - Enables cross-origin dev setup (Vite + backend)
2. **Future-proofs codebase** - Supports multi-origin SaaS scenarios
3. **Low risk to implement** - Straightforward refactor with comprehensive patterns
4. **Excellent for code quality** - Great first refactor task for new contributors

---

## Linting & Prevention

### Prevention (No ESLint Currently Configured)

The project does not currently use ESLint. The most pragmatic regression prevention is a grep-based pre-commit check:

**Add to `.git/hooks/pre-commit` or CI pipeline:**
```bash
# Verify no fetch calls use authHeaders() without credentials: 'include'
broken=$(grep -n "\.\.\.authHeaders()" /data/NesVentory/src/lib/api.ts | \
  grep -v "createFetchOptions\|credentials:")
if [ -n "$broken" ]; then
  echo "ERROR: fetch calls using authHeaders() without credentials:"
  echo "$broken"
  exit 1
fi
```

If ESLint is added to the project in the future, the correct approach is ESLint's built-in `no-restricted-syntax` rule with an AST selector — not a custom plugin. ESLint rules operate on ASTs, not string regex patterns. A custom plugin would require a `eslint-local-rules/` directory.

---

## Pre-Existing Bug (Out of Scope — Note for Awareness)

Approximately 20 DELETE/mutation functions in `src/lib/api.ts` use inline `if (!res.ok)` error handling rather than routing through `handleResponse()`. These functions throw on 401 errors but never dispatch the `window.dispatchEvent(new Event("auth:unauthorized"))` event, meaning an expired session during a delete operation shows an error toast but does not redirect to the login page. This is unrelated to the credentials refactor and should be tracked separately.

Affected pattern example: `deleteLocation`, `deleteItem`, `deletePhoto`, `deleteDocument`, `deleteTag`, `deleteUser`, `deletePlugin`, `deleteGDriveBackup`, `deleteMaintenanceTask`, `bulkDeleteMedia`.

---

## Related Issues

This technical debt is foundational for:

1. **Phase 5: Dashboard** - Ensures cross-origin API calls work reliably in dev mode
2. **Phase 7: Team Collaboration** - Multi-origin setup will require consistent credentials handling
3. **Future SaaS** - Cloud deployments often have separate API and UI origins

---

## Success Criteria

- [x] All fetch calls in `src/lib/api.ts` use `createFetchOptions()` or explicit `credentials: 'include'`
- [x] TypeScript compilation succeeds
- [x] All existing functionality still works (regression test)
- [x] Cross-origin dev setup works (Vite on port 5173 + API on port 8181)
- [x] No console errors for 401 Unauthorized (proves cookies are sent)
- [x] Code review approval from team

---

## Frequently Asked Questions

### Q: Why not use axios with a global interceptor?
**A:** Current approach is lighter weight, explicit, and works well. Axios adds bundle size for a simpler benefit here.

### Q: Will this break Bearer token support?
**A:** No. If the backend ever falls back to Authorization header, we'd add that to `authHeaders()`. Current implementation is forward-compatible.

### Q: Why did Phase 2D printer functions get this right?
**A:** They were added recently (Feb 2026) after the cookie migration was finalized. Earlier code predates the migration.

### Q: Should we remove the authHeaders() function entirely?
**A:** Not yet. Keep it for potential future use (Bearer fallback, custom auth schemes). Mark it as deprecated in comments.

### Q: Can I do this incrementally?
**A:** Yes. Option C (hybrid approach) is valid. Update functions as you touch them during feature work. But batch refactor is preferred for consistency.

---

## Next Steps

1. **Immediate (ready to start):**
   - Review this document with team
   - Decide on Option A (createFetchOptions) vs Option B vs Option C
   - Assign one developer for 5-6 hour sprint

2. **Short-term (after refactor):**
   - Add ESLint rule to prevent regression
   - Update code style guide / CONTRIBUTING.md
   - Include in code review checklist

3. **Long-term:**
   - Monitor for any 401 errors post-refactor
   - Use as pattern for future API client improvements

---

## Appendix: Summary of Changes

**Files Modified:** 1 (`src/lib/api.ts`)
**Lines Changed:** ~300+ (across ~88 functions with 99 call-sites)
**Breaking Changes:** None
**New Dependencies:** None
**Migration Needed:** No (backward compatible)

**Before & After:**
- **Before:** **3** functions use `createFetchOptions()`, **~88** functions (99 call-sites) use `authHeaders()` without credentials
- **After:** All ~88 functions consistently use `createFetchOptions()`

---

**Document Version:** 1.1 (Revised after code review — 2026-02-21)
**Last Updated:** 2026-02-21
**Status:** Ready for Implementation
**Estimated Sprint:** Week of 2026-03-03 (Q1 Week 10)

**Review Notes:** Revised to correct SameSite value, ESLint package reference, scope counts, section headers, and cross-origin dev guidance. Core recommendation (Option A) unchanged.
